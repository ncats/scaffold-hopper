// $Id: ContinuousDensityEstimator.java 3491 2009-10-29 15:51:42Z nguyenda $

package gov.nih.ncgc.math.stat;

import java.util.Random;
import cern.jet.stat.Probability;
import cern.jet.random.*;
import cern.jet.random.engine.RandomEngine;

public class ContinuousDensityEstimator extends DensityEstimator {

    static final double ONE_SQRT2 = 0.70710678118654752440;

    protected double sigma = 0.5; // default smoothing parameter
    protected double spread = 1.41421356237; // 1/(sigma*sqrt(2))

    public ContinuousDensityEstimator (int nbins) {
	this (0.5, nbins);
    }

    public ContinuousDensityEstimator (double sigma, int nbins) {
	super (nbins);
	setSigma (sigma);
    }

    public ContinuousDensityEstimator (int nbins, double min, double max) {
	super (nbins, min, max);
    }

    public void setSigma (double sigma) { 
	this.sigma = sigma;
	this.spread = ONE_SQRT2/sigma;
    }
    public double getSigma () { return sigma; }
    
    // override parent's
    public void increment (double x) {
	int b = find (x);
	// ignore -inf & +inf
	if (b >= 0 && b < bin.length) {
	    double left = range[b], right = range[b+1];
	    double wt = Probability.errorFunction((right - x) * spread)
		- Probability.errorFunction((left - x) * spread);
	    increment (x, wt);
	}
    }

    public void estimate () {
	// normalize the density.. ignoring the -inf and +inf bins? 
	double wt = 0.; 
	for (int i = 0; i < bin.length; ++i) {
	    bin[i] *= 0.5;
	    wt += bin[i];
	}

	// now normalize
	double n = wt + bin.length/wt;
	double wt0 = 1./wt;

	for (int i = 0; i < bin.length; ++i) {
	    bin[i] = (bin[i] + wt0)/n;
	}
    }

    /*
     * the pdf is generated by suposition of bin.length gaussian kernels
     */
    public double probability (double x) {
	// contribution from every bin
	double z = 0., left, right, wt;
	for (int i = 0; i < bin.length; ++i) {
	    left = range[i];
	    right = range[i+1];
	    // calculate contribution of this bin to x
	    wt = Probability.errorFunction((right - x)*spread) 
		- Probability.errorFunction((left-x)*spread);
	    z += bin[i] * wt;
	}
	z /= 2.;
	return z;
    }

    public static void main (String[] argv) throws Exception {
	int N = 100;
	if (argv.length > 0) {
	    N = Integer.parseInt(argv[0]);
	}
	System.err.println("# bins = " + N);
	ContinuousDensityEstimator pdf = 
	    new ContinuousDensityEstimator (N, -10, 10.);
	if (argv.length > 1) {
	    double sigma = Double.parseDouble(argv[1]);
	    pdf.setSigma(sigma);
	}

	Random rand = new Random ();
	int M = N*5; // rand.nextInt(500);
	System.err.println("## generating " + M + " random values");
	System.err.println("## sigma = " +pdf.getSigma());

	Gamma g = new Gamma (0.5, 0.2, RandomEngine.makeDefault());
	Hyperbolic h = new Hyperbolic (0.5, 0.1, RandomEngine.makeDefault());
	double[] x = new double[M];
	for (int i = 0; i < M; ++i) {
	    x[i] = 
		//rand.nextGaussian();
		//g.nextDouble();
		h.nextDouble();
	    pdf.increment(x[i]);
	}
	java.util.Arrays.sort(x);

	// now estimate
	pdf.estimate();
	double err = 0.;
	for (int i = 0; i < M; ++i) {
	    double y = pdf.probability(x[i]);
	    //double e = y - g.pdf(x[i]);
	    //err += e*e;
	    System.out.println(x[i] + " " + y);
	}
	System.err.println("rmse = " + (Math.sqrt(err/M)));
	System.err.println("pdf(-11) = " + pdf.probability(-11.));
	System.err.println("pdf(11) = " + pdf.probability(11));
	System.err.println("pdf(0) = " + pdf.probability(0.));
    }
}
